(신규 아이디 추천)
 - 문제 단계별 프로세스에 맞게 진행

(문자열 압축)
 - 문자열 길이 slicing 단위 구하기 (약수로 나눠야 공평하게 나눠짐) -> (함수 1)
 - 약수 저장되어 있는 길이 만큼 slicing하여 길이 측정 (int 반환) -> (함수 2)
  ※ 길이 구하는 방법
   1) 먼저 자른 것을 string 배열에 저장
   2) 동일한 것이 나오지 않을 때까지 count를 증가
   3) 1인 경우는 1붙이지 않고 나머지는 숫자붙여서
   4) 최종적으로 나온 길이 반환
 - 측정된 길이를 비교

(메뉴 리뉴얼)
 - 모든 조합들을 합하여 계산 (bit 활성화 -> 2의 n승은 제외) -> 나온 조합을 set에 저장
 - 저장된 set을 map에 매핑 (새로운 것이면 1, 아니면 +1)
 - map을 순회하면서 course[i]에 맞는 것들을 result에 저장 (course[i]: 단품 갯수, 주문이 많이 된것)

(괄호 변환)
1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.
2. 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리합니다. 단, u는 "균형잡힌 괄호 문자열"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.
3. 문자열 u가 "올바른 괄호 문자열" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.
  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.
4. 문자열 u가 "올바른 괄호 문자열"이 아니라면 아래 과정을 수행합니다.
  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다.
  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.
  4-3. ')'를 다시 붙입니다.
  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.
  4-5. 생성된 문자열을 반환합니다.

(순위 검색)
[정확성만 고려]
1. query를 slicing 공백을 기준 (개발언어, 직군, 경력, 소울푸드) => and는 넣지 않기
2. slicing된 query를 info랑 일일이 비교하여 counting => info도 slicing

[효율성까지 고려]
1. info에 대한 모든 경우의 집합 구하기 (16가지)
2. 16가지를 문자열로 한번에 묶기 -> 문자열 더하기 연산
3. 나온 문자열을 key, 나온 점수를 value로 map으로 전환 (1개 이상이면 계속 push)
4. query를 convert (점수 앞까지만 더해서 문자열 반환)